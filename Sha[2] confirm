//========================
//Some preliminary objects
//========================
R<T>:=PolynomialRing(Rationals());
U<u0,u1,u2,u3,u4> := PolynomialRing(Rationals(),5);

Q4 := u0*u3 - 17*u1*u2;
Q3 := -12*u0^2 + 204*u1^2 + 408*u2^2 + 25*u3^2 - 2*u4^2;

X:=Scheme(ProjectiveSpace(U),[Q3,Q4]);
//PointSearch(X,100);
//for p in PrimesUpTo(100) do
//    IsLocallySoluble(X,p);
//end for;

M3:=SymmetricMatrix(Q4);
M4:=SymmetricMatrix(Q3);

f := Determinant(M3+T*M4);

print "f: ", Factorisation(f);
print "LC(f): ", LeadingCoefficient(f);

D:=Numerator(Discriminant(f));
print "Delta:", Factorisation(D);

f1:=Factorisation(f)[1][1];
f2:=Factorisation(f)[2][1];
f3:=Factorisation(f)[3][1];

L1<rat>:=quo<R|f1>;
L2<sqy> := quo<R | f2>;
L3<the> := quo<R | f3>;

M:=M3+sqy*M4;
vs := Matrix(Basis(Image(M)));
QuadraticForm(vs*M*Transpose(vs));
epsilon1:=Determinant(vs*M*Transpose(vs));
print "epsilon1: ", epsilon1;
print "Is epsilon1 square?", IsSquare(epsilon1);

M:=M3+sqy*M4;
vs := Matrix(Basis(Image(M)));
Q:=QuadraticForm(vs*M*Transpose(vs));
epsilon2:=Determinant(vs*M*Transpose(vs));
print "epsilon2: ", epsilon2;
print "Norm(epsilon2):", Norm(epsilon2);
print "Is Norm(epsilon2) square?", IsSquare(Norm(epsilon2));
print "Is epsilon2 square?", IsSquare(epsilon2);

POINT:=[0,0,1,120*sqy];
Evaluate(Q,POINT) eq 0;

M:=M3+the*M4;
vs := Matrix(Basis(Image(M)));
epsilon3:=Determinant(vs*M*Transpose(vs));
print "epsilon3: ", epsilon3;
print "Norm(epsilon3):", Norm(epsilon3);
print "Is epsilon3 square?", IsSquare(epsilon3);


//========================
//Computing the Azumaya algebra
//========================

P := POINT[1..4];
P2 := Matrix(L2,4,1,[P[1],P[2],P[3],P[4]]);
P4<o0,o1,o2,o3,o4> := ProjectiveSpace(L2,4);
Q := SymmetricMatrix(Q);
Derivative := (Q+Transpose(Q))*P2;
Line := Derivative[1][1]*(o0-P[1])+Derivative[2][1]*(o1-P[2])+Derivative[3][1]*(o2-P[3])+Derivative[4][1]*(o3-P[4]);
Line;


//========================
//Computing the Brauer group
//========================


Length:=#(Factorisation(f));

Factors:=function(f,k)
list:={};
for i in Factorisation(f) do
    if Degree(i[1]) eq k then
        Include(~list, <i[1],Index(Factorisation(f), i)>);
    end if;
end for;
    return list, Type(list);
end function;

Factors3:=function(f)
list:={};
for i in Factorisation(f) do
    if Degree(i[1]) eq 1 then
        Include(~list, <i[1],Index(Factorisation(f), i)>);
    end if;
    if Degree(i[1]) eq 3 then
        Include(~list, <i[1],Index(Factorisation(f), i)>);
    end if;
end for;
    return list;
end function;


BrauerGroup:=function(f,deltas)
correct:=[];
if #Factors(f,5) eq 1 then
    return CyclicGroup(1);
else
    if #Factors(f,4) eq 1 then
        return CyclicGroup(1);
    end if;
end if;
if #Factors(f,1) ge 3 then
for s in Subsets(Factors(f,1),3) do
    Test1 := &and[IsSquare(deltas[i[2]]) ne true : i in s];
    Test2 := &and[IsSquare(LL!deltas[i[2]]*LL!deltas[j[2]]) where LL:=Compositum(Lis[i[2]],Lis[j[2]]): i, j in t, t in Subsets(s,2)]; 
    if Test1 and Test2 then
        Append(~correct, s);
        r:=correct[1];
        return "BrX/Br0X=id", (deltas[s[1]],TangentLine(s[1])*TangentLine(s[2])^{-1}), (deltas[s[1]],TangentLine(s[1])*TangentLine(s[3])^{-1}),(deltas[s[1]],TangentLine(s[3])*TangentLine(s[2])^{-1});
    end if;
end for;
end if;
for s in Exclude(Subsets(Factors(f,2)),{}) do
    Test1 := &and[IsSquare(deltas[i[2]]) ne true : i in s];
    Test2 := IsSquare(&*[Norm(deltas[i[2]]): i in s]) eq true;
if Test1 and Test2 then
    for t in Factors3(f) do
	if IsSquare(deltas[t[2]]) ne true then
            //fix this
            ell:=(o1+o2)^(-2);
            X:=[];
            for i in s do
                List:=Coefficients(TangentLine(i[2]));
                List2:=[Norm(x): x in List];
                Append(~X,List2[1]*S1.1+List2[2]*S1.2+List2[3]*S1.3+List2[4]*S1.4+List2[5]);
            end for;
            return "BrX/Br0X=id,", ell*&*X;
//return CyclicGroup(2), s, t
	end if;
end for;
end if;
end for;
    return CyclicGroup(1);
end function;
BrauerGroup(f,deltas);





Norm(epsilon2);
Norm(epsilon3);
